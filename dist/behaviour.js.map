{"version":3,"sources":["src/behaviour.js"],"names":[],"mappings":"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","file":"src/behaviour.js","sourcesContent":["'use strict';\n\nimport { Graph, alg as GraphAlgo } from 'graphlib';\n\nconst normalizeAction = (action) => {\n    let nextState;\n    let apply = (d) => d;\n    let check = (d) => true;\n\n    if(typeof action === 'string') {\n        nextState = action;\n    } else if(action instanceof Array) {\n        nextState = action.length > 0 ? action[0] : null;\n        if(action.length > 1 && typeof action[1] === 'object') {\n            if('apply' in action[1] && typeof action[1].apply === 'function') { apply = action[1].apply; }\n            if('check' in action[1] && typeof action[1].check === 'function') { check = action[1].check; }\n        }\n    }\n\n    return { nextState, apply, check };\n};\n\nexport default class BaseFSM {\n\n    constructor({ getState, setState, states }) {\n\n        this.getState = getState;\n        this.setState = setState;\n\n        // Normalizing actions list\n        this.statesNormalized = {};\n        for(let state in states) {\n\n            let stateSpecs = {};\n\n            for(let actionName in states[state]) {\n                stateSpecs[actionName] = normalizeAction(states[state][actionName]);\n            }\n\n            this.statesNormalized[state] = stateSpecs;\n        }\n\n        // Building directed graph of states\n        const g = new Graph();\n        for(let state in this.statesNormalized) {\n            g.setNode(state);\n        }\n\n        for(let state in this.statesNormalized) {\n            for(const actionName in this.statesNormalized[state]) {\n                const action = this.statesNormalized[state][actionName];\n                this._assertState(action.nextState);\n\n                // graph is directional, so actionName is always considered as a transition from state to nextState\n                g.setEdge(state, action.nextState, actionName);\n            }\n        }\n\n        // Calculating shortest pathes between states\n        const stateDistances = GraphAlgo.floydWarshall(g);\n        this.getTransitionsBetween = (from, to) => {\n\n            let transitions = [];\n            if(from === to) { return transitions; }\n\n            const distances = stateDistances[from];\n\n            let step = { node: to, info: distances[to] };\n\n            if(!('predecessor' in step.info)) { return null; }\n\n            while('predecessor' in step.info) {\n                transitions.push({ state: step.info.predecessor, action: g.edge(step.info.predecessor, step.node) });\n                step = { node: step.info.predecessor, info: distances[step.info.predecessor] };\n            }\n\n            transitions.reverse();\n            return transitions;\n        };\n\n        /*\n        console.log(Etat.NOUVELLE + '~>' + Etat.EN_COURS, this.getTransitionsBetween(Etat.NOUVELLE, Etat.EN_COURS));\n        console.log(Etat.NOUVELLE + '~>' + Etat.NOUVELLE, this.getTransitionsBetween(Etat.NOUVELLE, Etat.NOUVELLE));\n        console.log(Etat.NOUVELLE + '~>' + Etat.ARCHIVEE, this.getTransitionsBetween(Etat.NOUVELLE, Etat.ARCHIVEE));\n        console.log(Etat.EN_COURS + '~>' + Etat.NOUVELLE, this.getTransitionsBetween(Etat.EN_COURS, Etat.NOUVELLE));\n        */\n    }\n\n    getActionForState(state, actionName) {\n        if(!(state in this.statesNormalized) || !(actionName in this.statesNormalized[state])) { return null; }\n        return this.statesNormalized[state][actionName];\n    }\n\n    handle(method, data, ...extraargs) {\n        const state = this.getState(data);\n        const action = this.getActionForState(state, method);\n        if(action === null) { return data; }\n        data = action.apply(data, ...extraargs);\n        return this.setState(data, action.nextState);\n    }\n\n    check(origData, targetData) {\n        const origState = this.getState(origData);\n        const targetState = this.getState(targetData);\n\n        this._assertState(origState);\n        this._assertState(targetState);\n\n        if(origState === targetState) { return true; }\n\n        const transitions = this.getTransitionsBetween(origState, targetState);\n\n        // pas de chemin entre les deux états\n        if(transitions === null) { return false; }\n        if(transitions.length > 1) { return false; }    // il est impossible de vérifier la cohérence réultante de plusieurs transitions d'affilée\n\n        let transition = transitions[0];\n        let action = this.getActionForState(transition.state, transition.action);\n        if(action === null) { return false; }\n\n        return action.check(targetData);\n    }\n\n    _assertState(state) {\n        if(!(state in this.statesNormalized)) { throw new Error('Invalid state:' + state); }\n    }\n}\n"]}